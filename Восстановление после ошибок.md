# Восстановление после ошибок 

### 1. Запуск

Парсер: `python ./parser.py <путь для файла, который нужно проанализировать >  <путь до директории, в которую можно положить временный файл>` 

Все ошибки будут записаны в файл `file.out`, который будет создан рядом с анализируемым файлом

### 2. Мои задачи 

- лексер и парсер для конктретного языка, написанные с помощью `ply.lex`  и `ply.yacc`
- реализация одной стратегии
- тесты

### 3. Синтаксис языка

Грамматики со следующими правилами:

- стартовый терминал отделяется `< >`
- нетерминалы `' '`
- терминалы `" "`
- пустая строка : `e`
- правило:
  - `нетерминал = (терминалы и нетерминалы) ,`  
  - каждое правило должно располгаться на одной строке
  - пустых строк быть не должно

Пример корректной грамматики:

```
<E> = e,
`E` = "["`E`"]",
`E` = `E``E`,
```

### 4. Стратегия

Использовалась стратегия Phase Level Recovery ([ссылка](https://www.geeksforgeeks.org/error-recovery-strategies-in-compiler-design/)). В этой стратегии происходит исправление ошибок по мере их нахождения: обрабатывается одна строчка, если в ней найдена какая-то ошибка, то происходит исправление этой ошибки, анализ не переходит на новую строку, пока текущая строка не будет полностью корректна (например, в примере, приведенном ниже, в первой строке сначала идет замена двух токенов на один нетерминал, а затем вставка запятой).

###### Пример работы:

###### Тест:

```
<E> `A` = e
`E` = "(" `E` ")"

`E` = e
`E` "a"
```

###### Вывод:

```
You should use one non_terminal before arrow :1
Expected `,` :1
Expected `,` :2
Expected rule :3
Expected `,` :4
Expected rule :5
```

##### Плюсы стратегии:

- можно легко применить к разным грамматикам

##### Минусы стратегии:

- необходимость проанализировать и обработать каждую конкретную ошибку, а также продумать, как её исправить

